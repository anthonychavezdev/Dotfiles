#+TITLE: Emacs config
#+AUTHOR: Anthony
#+LANGUAGE: en
#+OPTIONS: num:nil

* Quality of life
** Show widened line numbered when in narrow mode
   #+begin_src emacs-lisp
     (setq-default display-line-numbers-widen t)
   #+end_src
** Allow nested minibuffers
   #+begin_src emacs-lisp
     (setq enable-recursive-minibuffers t)
     (minibuffer-depth-indicate-mode 1)
   #+end_src
** Keep the cursor out of the read-only portions of the minibuffer
   #+begin_src emacs-lisp
     (setq minibuffer-prompt-properties
           '(read-only t intangible t cursor-intangible t face
                       minibuffer-prompt))
     (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
   #+end_src
** Disable the warning "X and Y are the same file"
   Ignoring this warning is acceptable since it will redirect you
   to the existing buffer regardless.
   #+begin_src emacs-lisp
     (setq find-file-suppress-same-file-warnings t)
   #+end_src
** Resolve symlinks when opening files
   #+begin_src emacs-lisp
     (setq find-file-visit-truename t
           vc-follow-symlinks t)
   #+end_src
** Enable line numbers
   Emacs breaks certain modes when it has line-numbers-mode enabled, (like docview or ansi-term) so I utilize the approach of only enabling it on some major modes rather than globally
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'display-line-numbers-mode)
   #+END_SRC
** Show parent parentheses
   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC
** Disable the default startup screen
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC
** Enable copypasting outside of Emacs
   #+BEGIN_SRC emacs-lisp
     (setq select-enable-clipboard t)
   #+END_SRC
** Move automatic creation of backup files
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
     ;; disk space is cheap
     (setq make-backup-files nil)
     (setq delete-old-versions -1)
     (setq version-control t)
     (setq vc-make-backup-files t)
     (setq auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "auto-save-list") t)))
   #+END_SRC
** Enable conservative scrolling
   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC
** Disable ring-bell
   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC
** Indentation
   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 4)
     (setq-default standard-indent 4)
     (setq c-basic-offset tab-width)
     (setq-default electric-indent-inhibit t)
     ;; Use spaces instead of tabs
     (setq-default indent-tabs-mode nil)
     (setq backward-delete-char-untabify-method 'nil)
   #+END_SRC
** Enable bracket pair-matching
   #+BEGIN_SRC emacs-lisp
     (setq electric-pair-pairs '(
                                 (?\{ . ?\})
                                 (?\( . ?\))
                                 (?\[ . ?\])
                                 (?\" . ?\")
                                 ))
     (electric-pair-mode t)
   #+END_SRC
** Creating a new window switches your cursor to it
   #+BEGIN_SRC emacs-lisp
     (defun split-and-follow-horizontally ()
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))
     (global-set-key (kbd "C-x 2") #'split-and-follow-horizontally)

     (defun split-and-follow-vertically ()
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))
     (global-set-key (kbd "C-x 3") #'split-and-follow-vertically)
   #+END_SRC
** Transform yes-or-no questions into y-or-n
   #+BEGIN_SRC emacs-lisp
     (if (version< emacs-version "28.1")
         (defalias 'yes-or-no-p 'y-or-n-p)
       (setq use-short-answers 1))
   #+END_SRC
** Easier resize bindigs
   Super - Control - <arrow>
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-C-<left>")  #'shrink-window-horizontally)
     (global-set-key (kbd "s-C-<right>") #'enlarge-window-horizontally)
     (global-set-key (kbd "s-C-<down>")  #'shrink-window)
     (global-set-key (kbd "s-C-<up>")    #'enlarge-window)
   #+END_SRC
** Changing the font
   #+Begin_SRC emacs-lisp
     ;; From: https://emacsredux.com/blog/2021/12/22/check-if-a-font-is-available-with-emacs-lisp/
     (defun font-available-p (font-name)
       (find-font (font-spec :name font-name)))

       (cond
        ((font-available-p "JetBrains Mono")
         (set-frame-font "JetBrains Mono"))
        ((font-available-p "Cascadia Code")
         (set-frame-font "Cascadia Code-12"))
        ((font-available-p "Menlo")
         (set-frame-font "Menlo-12"))
        ((font-available-p "DejaVu Sans Mono")
         (set-frame-font "DejaVu Sans Mono-12"))
        ((font-available-p "Inconsolata")
         (set-frame-font "Inconsolata-12"))
        ((font-available-p "Fira Code")
         (set-frame-font "Fira Code-12")))
   #+END_SRC
** Enable deleting selection by typing
   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode)
   #+END_SRC
** Taking screenshots
   #+BEGIN_SRC emacs-lisp
     (defun screenshot-svg ()
       "Save a screenshot of the current frame as an SVG image.
     Saves to a temp file and puts the filename in the kill ring."
       (interactive)
       (let* ((filename (make-temp-file "Emacs" nil ".svg"))
              (data (x-export-frames nil 'svg)))
         (with-temp-file filename
           (insert data))
         (kill-new filename)
         (message filename)))

     (defun screenshot-png ()
       "Save a screenshot of the current frame as a PNG image.
     Saves to a temp file and puts the filename in the kill ring."
       (interactive)
       (let* ((filename (make-temp-file "Emacs" nil ".png"))
              (data (x-export-frames nil 'png)))
         (with-temp-file filename
           (insert data))
         (kill-new filename)
         (message filename)))

   #+END_SRC
** Hide-mode-line plugin
   #+BEGIN_SRC emacs-lisp
     (use-package hide-mode-line
       :straight t
       :commands hide-mode-line-mode)
   #+END_SRC
** Compilation-mode customizations
   #+begin_src emacs-lisp
     ;;; From https://emacs.stackexchange.com/questions/24698/ansi-escape-sequences-in-compilation-mode

     ;; Have ansi escape codes appear as colors in the compilation window
     ;; Stolen from (http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html)
     (require 'ansi-color)
     (defun endless/colorize-compilation ()
       "Colorize from `compilation-filter-start' to `point'."
       (let ((inhibit-read-only t))
         (ansi-color-apply-on-region
          compilation-filter-start (point))))

     (add-hook 'compilation-filter-hook
               #'endless/colorize-compilation)

     ;; Filter out unwanted ansi codes
     ;; Stolen from (https://oleksandrmanzyuk.wordpress.com/2011/11/05/better-emacs-shell-part-i/)
     (defun regexp-alternatives (regexps)
       "Return the alternation of a list of regexps."
       (mapconcat #'(lambda (regexp)
                      (concat "\\(?:" regexp "\\)"))
                  regexps "\\|"))

     (defvar non-sgr-control-sequence-regexp nil
       "Regexp that matches non-SGR control sequences.")

     (setq non-sgr-control-sequence-regexp
           (regexp-alternatives
            '(;; icon name escape sequences
              "\033\\][0-2];.*?\007"
              ;; non-SGR CSI escape sequences
              "\033\\[\\??[0-9;]*[^0-9;m]"
              ;; noop
              "\012\033\\[2K\033\\[1F"
              )))

     (defun filter-non-sgr-control-sequences-in-region (begin end)
       (save-excursion
         (goto-char begin)
         (while (re-search-forward
                 non-sgr-control-sequence-regexp end t)
           (replace-match ""))))

     (defun filter-non-sgr-control-sequences-in-output (ignored)
       (let ((start-marker
              (or comint-last-output-start
                  (point-min-marker)))
             (end-marker
              (process-mark
               (get-buffer-process (current-buffer)))))
         (filter-non-sgr-control-sequences-in-region
          start-marker
          end-marker)))

     (add-hook 'comint-output-filter-functions
               'filter-non-sgr-control-sequences-in-output)
   #+end_src
** Sentences end with a single space
   #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
   #+END_SRC
** Display the time in the modeline
   #+BEGIN_SRC emacs-lisp
     (display-time-mode 1)
   #+END_SRC
** Increase the max amount that can be stored in the kill ring
   #+BEGIN_SRC emacs-lisp
     (setq kill-ring-max 10000)
   #+END_SRC
** UTF-8 Encoding
   I want text to be encoded in utf8
   #+begin_src emacs-lisp
     (set-default-coding-systems 'utf-8)  ; Default to utf-8 encoding
     (prefer-coding-system 'utf-8)        ; Add utf-8 at the front for automatic detection.
     (set-terminal-coding-system 'utf-8)  ; Set coding system of terminal output
     (set-keyboard-coding-system 'utf-8)  ; Set coding system for keyboard input on TERMINAL
     (set-language-environment "English") ; Set up multilingual environment
   #+end_src
** Remove text properties from kill-ring
   I don't want text properties to be killed (copied or cut), I just want the plain text
   #+begin_src emacs-lisp
     (defun unpropertize-kill-ring ()
       (setq kill-ring (mapcar 'substring-no-properties kill-ring)))

     (add-hook 'kill-emacs-hook 'unpropertize-kill-ring)
   #+end_src
** Better window navigation
*** Enable and install ace-window
    #+begin_src emacs-lisp
      (use-package ace-window
        :straight t
        :bind (("M-o" . ace-window)))
    #+end_src
** Copy file name or directory path to clipboard
   #+begin_src emacs-lisp
     (defun acd/copy-file-name-or-path ()
       (interactive)
       (let ((filename (if (equal major-mode 'dired-mode)
                           default-directory
                         (buffer-file-name))))
         (when filename
           (kill-new filename)
           (message "Copied file name '%s' to clipboard" filename))))
   #+end_src
** Version Control
*** Ignore files
    #+begin_src emacs-lisp
     (add-to-list 'vc-directory-exclusion-list "node_modules")
    #+end_src
** Highlight line when switching windows
   #+begin_src emacs-lisp
     (defun acd/flash-on-window-chagne (ignored-arg)
       (pulse-momentary-highlight-one-line (point)))
     (add-to-list 'window-selection-change-functions #'acd/flash-on-window-chagne)
   #+end_src
** Better help system
   #+begin_src emacs-lisp
     (use-package helpful
       :straight t
       :bind (("C-h f" . helpful-callable)
              ("C-h v" . helpful-variable)
              ("C-h k" . helpful-key)
              ("C-h x" . helpful-command)
              ("C-h d" . helpful-at-point)
              ("C-h F" . helpful-function)))
   #+end_src
** Highlight keywords like TODO, FIXME, etc
   #+begin_src emacs-lisp
     (use-package hl-todo
       :straight t
       :hook (prog-mode . hl-todo-mode)
       :custom ((hl-todo-highlight-punctuation ":")
                (hl-todo-keyword-faces
                 `(("TODO"       warning bold)
                   ("FIXME"      error bold)
                   ("HACK"       font-lock-constant-face bold)
                   ("REVIEW"     font-lock-keyword-face bold)
                   ("NOTE"       success bold)
                   ("DEPRECATED" font-lock-doc-face bold)))))
   #+end_src
* Custom functionality
** imenu
   map imenu to M-i
   #+begin_src emacs-lisp
     (global-set-key (kbd "M-i") #'imenu)
   #+end_src
** set tramp terminal type
   #+begin_src emacs-lisp
     (setq tramp-terminal-type "tramp")
   #+end_src
** Dired
   #+begin_src emacs-lisp
     (add-hook 'dired-mode-hook #'dired-hide-details-mode)
     (setq dired-dwim-target t)
     ;; From https://emacs.stackexchange.com/questions/64982/copy-a-file-content-to-clipboard-with-dired
     (defun acd/copy-file-contents-in-dired ()
       (interactive)
       (let ((buffer (find-file-noselect (dired-get-file-for-visit))))
         (with-current-buffer buffer
           (kill-new (buffer-substring-no-properties (point-min) (point-max))))
         (kill-buffer buffer)))
   #+end_src
** Eval and replace
   #+begin_src emacs-lisp
     (defun narrow-to-line ()
       (interactive)
       (save-excursion
         (move-beginning-of-line 1)
         (set-mark (point))
         (move-end-of-line 1)
         (narrow-to-region (region-beginning) (region-end))
         (deactivate-mark)))

     (defun fc-eval-and-replace ()
       "Replace the preceding sexp with its value."
       (interactive)
       (backward-kill-sexp)
       (condition-case nil
           (prin1 (eval (read (current-kill 0)))
                  (current-buffer))
         (error (message "Invalid expression")
                (insert (current-kill 0)))))

     (defvar equation-re "(*[0-9]+)*\\([[:blank:]]*[+-\\*/^][[:blank:]]*(*[0-9]+)*\\)+")

     ;; From a comment at https://emacsredux.com/blog/2013/06/21/eval-and-replace/
     ;; by csar
     (defun calc-eval-and-insert (&optional start end)
       (interactive "r")
       (let ((result (calc-eval (buffer-substring-no-properties start end))))
         (if (region-active-p)
             (progn
               (kill-region start end)
               (insert result))
           (set-mark (point))
           (if (re-search-backward equation-re nil t 1)
               (progn
                 (calc-eval-and-insert (region-beginning) (region-end)))
             (message "Error")))))

     (defun try-eval-equation-or-elisp ()
       (interactive)
       (let ((equation nil))
         (save-excursion
           (narrow-to-line)
           (move-beginning-of-line 1)
           (if (re-search-forward equation-re nil t 1)
               (progn
                 (setq equation t)
                 (set-mark (match-beginning 0))
                 (widen))
             (widen)
             (setq equation nil))

         (if equation
             (calc-eval-and-insert (region-beginning) (region-end))
           (fc-eval-and-replace)))))

     (global-set-key (kbd "C-c e") #'try-eval-equation-or-elisp)

  #+end_src
** use hippie-expand instead of dabbrev-expand
   #+begin_src emacs-lisp
     (global-set-key [remap dabbrev-expand] #'hippie-expand)
   #+end_src
** Automations
   #+begin_src emacs-lisp
     (setq acd/ha-auth-token nil)
     (setq acd/ha-content-type "application/json")
     (setq acd/ha-url nil)
     (setq acd/ha-port nil)
     (setq acd/ha-api-endpoint nil)

     (defun acd/ha-print-response (data)
       (when data
         (with-current-buffer (get-buffer-create "*ha-response*")
           (erase-buffer)
           (insert data)
           (json-mode)
           (goto-char (point-min))
           (json-pretty-print-buffer)))
       (message "Saved to *ha-response* buffer"))

     (defun acd/ha-state-info (&optional entity_id)
       "Display home-assistant state information in a buffer"
       (interactive)
       (message "Fetching data...")
       (request (if entity_id
                    (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" acd/ha-api-endpoint "/" entity_id)
                  (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" acd/ha-api-endpoint))
         :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                    ("Content-Type" . ,acd/ha-content-type))
         :parser 'buffer-string
         :success (cl-function
                   (lambda (&key data &allow-other-keys)
                     (acd/ha-print-response data)))
         :error (cl-function
                 (lambda (&key error-thrown &allow-other-keys)
                   (message "Got error: %s" error-thrown)))))

     (defun acd/ha-turn-lights-off ()
       "Turn lights off"
       (interactive)
       (message "Turning lights off...")
       (let ((endpoint "services/light/turn_off"))
         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e11_n1ea_faae0100_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))
         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e11_n1ea_db510200_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))

         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e21_n1ea_e3c01700_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))))

     (defun acd/ha-turn-lights-on ()
       "Turn lights on"
       (interactive)
       (message "Turning lights on...")
       (let ((endpoint "services/light/turn_on"))
         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e11_n1ea_faae0100_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))
         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e11_n1ea_db510200_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))

         (request (concat acd/ha-url ":" (number-to-string acd/ha-port) "/api/" endpoint)
           :headers `(("Authorization" . ,(concat "Bearer " acd/ha-auth-token))
                      ("Content-Type" . ,acd/ha-content-type))
           :type "POST"
           :data (json-encode '(("entity_id" . "light.sengled_e21_n1ea_e3c01700_level_light_color_on_off")))
           :success (cl-function
                     (lambda (&key data &allow-other-keys)
                       (acd/ha-print-response data)))
           :error (lambda (error-m)
                    (message "Got error: %s" error-thrown)))))

     (progn
       (define-prefix-command 'automation-map)
       (define-key automation-map (kbd "l o") #'acd/ha-turn-lights-on)
       (define-key automation-map (kbd "l f") #'acd/ha-turn-lights-off))
     (global-set-key (kbd "C-c a") 'automation-map)
   #+end_src
** Duplicate line
   #+begin_src emacs-lisp
     (defun acd/duplicate-line (args)
       (interactive "p")
       (let ((num_lines (or args 1)))
         (dotimes (_ num_lines)
           (move-beginning-of-line 1)
           (kill-line)
           (yank)
           (newline)
           (yank))))

     (defun acd/duplicate-line-dwim (args)
       (interactive "p")
       (if (use-region-p)
           (progn
             (let ((start (region-beginning))
                   (end (region-end)))
               (goto-char end)
               (dotimes (_ (or args 1))
                 (newline)
                 (insert (buffer-substring start end)))))
         (acd/duplicate-line args)))

     (global-set-key (kbd "C-c d") #'acd/duplicate-line-dwim)
   #+end_src
** copy-line
   #+begin_src emacs-lisp
     (defun acd/kill-save-line ()
       (interactive)
       (kill-ring-save (line-beginning-position) (line-end-position))
       (message "Line copied"))

     (global-set-key (kbd "C-c w") #'acd/kill-save-line)

   #+end_src
** Compile / run programs
   #+begin_src emacs-lisp
     (defvar acd/already-compiled nil "nil if the program is being compiled for the first time,
         otherwise it's t")
     (defun acd/compile-or-recompile ()
       "Compile program. Recompile if the program has already been compiled
     to avoid prompting for the compilation command each time"
       (interactive)
       (if acd/already-compiled
           (recompile)
         (call-interactively 'compile)
         (setq acd/already-compiled t)))

     (global-set-key (kbd "C-c c") #'acd/compile-or-recompile)

   #+end_src
** Insert date from calendar
   #+begin_src emacs-lisp
     (defvar acd/date-format-options
       '(("%Y-%m-%d" . "YYYY-MM-DD")
         ("%d/%m/%Y" . "DD/MM/YYYY")
         ("%m/%d/%Y" . "MM/DD/YYYY")
         ("%B %d, %Y" . "Month DD, YYYY")
         ("%A, %B %d, %Y" . "Day, Month DD, YYYY"))
       "List of date format options for `acd/insert-date-from-cal'.")

     (defun acd/insert-date-from-cal (&optional arg)
       "Insert the date from the calendar at point into the last opened window, optionally followed by a specified character.
 The date is formatted according to the selected format or defaults to \"%Y-%m-%d\".
 If  ARG is non-nil, the user is prompted to enter a character to be inserted after the date.
 - If ARG is a single \\[universal-argument] (\\`(4)), the user is prompted for a character
 - If ARG is a double \\[universal-argument] (\\'(16)), the user is also prompted to select a date format
 from `acd/date-format-options' using `completing-read'.

 The formatted date is inserted into the previously active window, and the calendar window remains active."
       (interactive "P")
       (let* ((date (calendar-cursor-to-date))
              (format (if (equal arg '(16))
                          (let ((completion-extra-properties '(:annotation-function
                                                               (lambda (completion-candidate) (cdr (assoc completion-candidate acd/date-format-options))))))
                            (car (assoc (completing-read "Select a date format: " acd/date-format-options nil t) acd/date-format-options)))
                        "%Y-%m-%d"))
              (char (if arg
                        (let ((input (read-key-sequence "Enter a character to be inserted after the date: ")))
                          (if (equal input (kbd "RET"))
                              ?\n
                            (aref input 0)))
                      ?\s))
              (formatted-date (format-time-string format (encode-time 0 0 0 (nth 1 date) (nth 0 date) (nth 2 date)))))

         (other-window 1)
         (insert formatted-date char)
         (other-window 1)))

     (define-key calendar-mode-map (kbd "C-c i") #'acd/insert-date-from-cal)
   #+end_src
** Milliseconds to date
   #+begin_src emacs-lisp
     (defun acd/milliseconds-to-date (ms)
       (interactive (list (read-number "ms: ")))
       (let ((date (format-time-string "<%F %H:%M>" (seconds-to-time (/ ms 1000)))))
         (message date)
         (kill-new date)))
   #+end_src
** Decode JWT tokens
   #+begin_src emacs-lisp
     (defun acd/decode-jwt (&optional jwt)
       "Decode JWT in region and print it to a buffer"
       (interactive)
       (let* ((tok (if jwt jwt
                     (if (use-region-p)
                         (buffer-substring (region-beginning) (region-end))
                       (read-from-minibuffer "JWT: "))))
              (data (s-split "\\." tok))
              (header (cl-first data))
              (claims (cl-second data)))
         (with-temp-buffer
           (insert (format "%s\n%s"
                           (base64-decode-string header t)
                           (base64-decode-string claims t)))
           (json-pretty-print-buffer)
           (with-output-to-temp-buffer "*JWT*"
             (princ (buffer-string)))))
       t)
   #+end_src
* Org-mode
** Description
   One of the main selling points of Emacs! Org Mode!
** Code
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :straight t)

     (use-package org-bullets
       :straight t
       :hook (org-mode . org-bullets-mode))

     (defun echo-area-tooltips ()
       "Show tooltips in the echo area automatically for current buffer."
       (setq-local help-at-pt-display-when-idle t
                   help-at-pt-timer-delay 0)
       (help-at-pt-cancel-timer)
       (help-at-pt-set-timer))

     (add-hook 'org-mode-hook #'echo-area-tooltips)
     ;; Sets LaTeX preview size
     (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
   #+END_SRC

* Packages
** Initialize =diminish=
*** Description
    Hide chosen minor modes from showing up in the modeline
*** Code
    #+begin_src emacs-lisp
      (use-package diminish
        :straight t)
    #+end_src
** Initialize =async=
*** Description
    Utilize asynchronous processes whenever possible
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package async
        :straight t
        :hook ((dired-mode . dired-async-mode)))
    #+END_SRC
** Initialize =dired-rsync=
*** Code
    #+begin_src emacs-lisp
      (use-package dired-rsync-transient
        :bind (:map dired-mode-map
                    ("C-c C-x" . dired-rsync-transient)))
    #+end_src
** Initialize =all-the-icons=
*** Description
    Bring nice icons to emacs
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
          :straight t)

      (use-package all-the-icons-dired
        :straight t
        :hook
        (dired-mode . all-the-icons-dired-mode))
    #+END_SRC
** Initialize =all-the-icons-completion=
*** Code
    #+begin_src emacs-lisp
      (use-package all-the-icons-completion
        :straight t
        :hook ((marginalia-mode . all-the-icons-completion-marginalia-setup))
        :config
        (all-the-icons-completion-mode))
    #+end_src
** Initialize =vertico=
*** Description
    Vertico provides a performant and minimalistic vertical completion UI based on the default completion system
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package vertico
        :straight t
        :custom
        (vertico-cycle t)
        :config
        (vertico-mode))
    #+END_SRC
** Initialize =orderless=
   #+begin_src emacs-lisp
     (use-package orderless
        :straight t
        :custom
        (completion-styles '(orderless partial-completion basic))
        (completion-category-overrides '((file (styles basic partial-completion)))))
   #+end_src
** Initialize =undo-tree=
*** Description
    Emacs’s undo system allows you to recover any past state of a buffer. To do this, Emacs
    treats “undo” itself as just another editing action that can be undone. This can be
    confusing and difficult to use. If you make an edit while undoing multiple changes, you
    “break the undo chain”. To get back to where you were, you have to undo all the undos
    you just did, then undo all the changes you’d already undone before. Only then can you
    continue undoing from where you left off. If this sounds confusing, it’s because it is!
    Hence, a number of packages exist that replace it with the undo/redo system

    Instead of treating undo/redo as a linear sequence of changes, undo-tree-mode treats
    undo history as a branching tree of changes, similar to the way Vim handles it.
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package undo-tree
        :straight t
        :diminish undo-tree-mode
        ;; I don't want undo-tree files littered everywhere
        :custom ((undo-tree-history-directory-alist `(("." . ,(concat
                                                               user-emacs-directory
                                                               "undo-tree")))))
        :config
        (global-undo-tree-mode 1))
    #+END_SRC
** Initialize =projectile=
*** Description
    Projectile is a project interaction library for Emacs.
    Its goal is to provide a nice set of features
    operating on a project level without introducing
    external dependencies (when feasible).
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
       :straight t
       :bind-keymap ("C-c p" . projectile-command-map)
       :config
       (add-to-list 'projectile-globally-ignored-directories "^node_modules"))
    #+END_SRC
** Initialize =dashboard=
*** Description
    The frontend of Witchmacs; without this there'd be no Marisa in your Emacs startup screen
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package dashboard
        :straight t
        :config
        (dashboard-setup-startup-hook)
            (setq dashboard-set-heading-icons t)
            (setq dashboard-set-file-icons t)
            (setq dashboard-projects-backend 'projectile)
            (setq dashboard-items '((projects . 5)
                                    (recents . 5)
                                    (bookmarks . 5)
                                    (agenda . 5)))
        (setq dashboard-banner-logo-title "E M A C S - The worst text editor!")
        (setq dashboard-startup-banner (concat user-emacs-directory "emacs-logo.png"))
        (setq dashboard-center-content t)
        (setq dashboard-show-shortcuts nil)
        (setq dashboard-set-init-info t)
        ;; (setq dashboard-init-info (format "%d packages loaded in %s"
        ;;                                   (length package-activated-list) (emacs-init-time)))
        (setq dashboard-set-footer t)
        (setq dashboard-set-navigator t))
    #+END_SRC
** Initialize =magit=
*** Description
    Git porcelain for Emacs
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :straight t
        :hook ((magit-log-mode . hl-line-mode))
        :bind (("C-x g" . magit-status)))
    #+END_SRC
** Initialize =moody=
   #+begin_src emacs-lisp
     (use-package moody
       :hook ((after-init . (lambda ()
                                    (moody-replace-mode-line-buffer-identification)
                                    (moody-replace-vc-mode)
                                    (moody-replace-eldoc-minibuffer-message-function))))
       :config
       (setq x-underline-at-descent-line t))
   #+end_src
** Initialize =rainbow-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
        :straight t
        :diminish rainbow-mode
        :hook
        ((prog-mode . rainbow-mode)))
    #+END_SRC
** Initialize =rainbow-delimeters=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :straight (rainbow-delimiters :type git :host github :repo "Fanael/rainbow-delimiters")
        :diminish rainbow-delimiters-mode
        :hook
        ((prog-mode . rainbow-delimiters-mode)))
    #+END_SRC
** Initialize =which-key=
*** Description
    which-key is a minor mode for Emacs that displays the key bindings following your
    currently entered incomplete command
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :straight t
        :diminish which-key-mode
        :config
        (which-key-mode))
    #+END_SRC
** Initialize =define-word=
*** Code
    #+BEGIN_SRC emacs-lisp
  (use-package define-word
    :straight t
    :defer 3)
    #+END_SRC
** Initialize =pdf-tools=
*** Description
    View pdf files in Emacs
*** Code
    #+begin_src emacs-lisp
      (use-package pdf-tools
        :straight (pdf-tools :type git :host github :repo "vedang/pdf-tools")
        :magic ("%PDF" . pdf-view-mode)
        :config
        (pdf-tools-install)
        (setq-default pdf-view-display-size 'fit-width)
        ;; automatically annotate highlights
        (setq pdf-annot-activate-created-annotations t))
    #+end_src
** Initialize =expand-region=
*** Description
    Expand region increases the selected region by semantic units. Just keep pressing the key
    until it selects what you want.
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :straight t
        :bind (("C-=" . er/expand-region)))
    #+END_SRC
** Initialize =solaire-mode=
*** Description
    solaire-mode is an aesthetic plugin designed to visually distinguish "real" buffers (i.e.
    file-visiting code buffers where you do most of your work) from "unreal" buffers (like
    popups, sidebars, log buffers, terminals, etc) by giving the latter a slightly different
    -- often darker -- background
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package solaire-mode
        :straight t
        :config
        (solaire-global-mode +1))
    #+END_SRC
** Initialize =visual-regexp=
*** Description
    Live visual feedback for regex
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package visual-regexp
        :straight t
        :defer 2)
    #+END_SRC
** Initialize =visual-regexp-steroids=
*** Description
    visual-regexp-steroids is an extension to visual-regexp which
    enables the use of modern regexp engines
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package visual-regexp-steroids
        :straight t
        :bind (("C-c r" . vr/replace)
               ("C-c q" . vr/query-replace)
               ("C-M-s" . vr/isearch-forward)
               ("C-M-r" . vr/isearch-backward)
               ;; if you use multiple-cursors, this is for you:
               ;; ("C-c m" . vr/mc-mark)
               ))
    #+END_SRC
** Initialize =elfeed=
*** Description
    RSS Feeder
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package elfeed
        :straight t
        :defer 3
        :config
        (setq elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory)
              elfeed-show-entry-switch 'display-buffer
              elfeed-feeds '(("https://protesilaos.com/master.xml" prot-master)
                             ("https://jvns.ca/atom.xml" julia)
                             ("https://robertheaton.com/feed.xml" robert-heaton))))
    #+END_SRC
** Initialize =wrap-region=
*** Description
    Wrap Region is a minor mode for Emacs that wraps a region with punctuations.
*** Codoe
    #+begin_src emacs-lisp
      (use-package wrap-region
        :straight t
        :defer 3
        :config
        (wrap-region-mode t))
    #+end_src
** Initialize =novel.el=
*** Description
    Used to read ebpub books in Emacs
*** Code
    #+begin_src emacs-lisp
      (use-package esxml
        :straight t) ;; required by nov

      (use-package nov
        :straight (nov :type git :repo "https://depp.brause.cc/nov.el.git")
        :mode ("\\.epub\\'" . nov-mode))
    #+end_src
** Initialize =elcord=
*** Description
    Discord Presence in Emacs
*** Code
    #+begin_src emacs-lisp
      (use-package elcord
        :straight t
        :defer 3
        :config
        (setq elcord-display-buffer-details t)
        (setq elcord-buffer-details-format-function #'buffer-file-name))
    #+end_src
** Initialize =perspective.el=
   #+begin_src emacs-lisp
     (use-package perspective
       :straight t
       :demand t
       :bind
       (("C-x b" . persp-switch-to-buffer*)
        ("C-x k" . persp-kill-buffer*))
       :custom
       (persp-mode-prefix-key (kbd "C-c M-p"))
       :config
       (persp-mode))
   #+end_src
** Initialize =avy=
*** Description
    avy is a GNU Emacs package for jumping to visible text using a char-based decision tree.
    See also =ace-jump-mode= and =vim-easymotion= - avy uses the same idea.
*** Code
    #+begin_src emacs-lisp
      (use-package avy
        :straight t
        :bind (("M-g c" . avy-goto-char)
               ("M-g '" . avy-goto-char-2)
               ("M-g l" . avy-goto-line)
               ("M-g w" . avy-goto-word-1)
               ("M-g r" . avy-goto-word-0)))
    #+end_src
** Initialize =emacs-gif-screencast=
*** code
#+begin_src emacs-lisp
  (use-package gif-screencast
    :straight (gif-screencast :type git :host gitlab :repo "ambrevar/emacs-gif-screencast")
    :commands gif-screencast)
#+end_src
** Initialize =request.el=
*** Description
    Used to make HTTP requests
*** Code
#+begin_src emacs-lisp
  (use-package request
    :straight (request :type git :host github :repo "tkf/emacs-request")
    :defer 3)
#+end_src
** Initialize =marginalia=
*** Description
    This package provides marginalia-mode which adds marginalia to the
    minibuffer completions.
*** Code
    #+begin_src emacs-lisp
      ;; Enable rich annotations using the Marginalia package
      (use-package marginalia
        :straight t
        :after vertico
        :demand t
        :custom
        (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
        ;; Either bind `marginalia-cycle' globally or only in the minibuffer
        :bind (("M-A" . marginalia-cycle)
               :map minibuffer-local-map
               ("M-A" . marginalia-cycle))

        :config
        (marginalia-mode))
    #+end_src
** Initialize =exec-path-from-shell=
*** Description
    Use environemnt variables from the shell
*** Code
    #+begin_src emacs-lisp
      ;; If using ZSH, set the variables in `~/.zshenv'
      ;; I have a lot set in `~/.profile', but this package doesn't 
      ;; seem to check there. I have the following in my `~/.zprofile':
      ;;
      ;; [[ -f ~/.zshrc ]] && . ~/.zshrc
      ;; [[ -f ~/.profile ]] && . ~/.profile
      ;;
      ;; You might need to be logged in for the above to run, which might be why.
      ;; I don't care enough to look any deeper right now.
       (use-package exec-path-from-shell
         :straight t
         :custom ((exec-path-from-shell-arguments nil))
         :config
         (when (memq window-system '(mac ns x pgtk))
           (exec-path-from-shell-initialize)))
    #+end_src
** Initialize =ligature=
*** Code
    #+begin_src emacs-lisp
      (use-package ligature
        :straight t
        :config
        (ligature-set-ligatures 'prog-mode '("--" "---" "==" "===" "!=" "!==" "=!="
                                             "=:=" "=/=" "<=" ">=" "&&" "&&&" "&=" "++" "+++" "***" ";;" "!!"
                                             "??" "???" "?:" "?." "?=" "<:" ":<" ":>" ">:" "<:<" "<>" "<<<" ">>>"
                                             "<<" ">>" "||" "-|" "_|_" "|-" "||-" "|=" "||=" "##" "###" "####"
                                             "#{" "#[" "]#" "#(" "#?" "#_" "#_(" "#:" "#!" "#=" "^=" "<$>" "<$"
                                             "$>" "<+>" "<+" "+>" "<*>" "<*" "*>" "</" "</>" "/>" "<!--" "<#--"
                                             "-->" "->" "->>" "<<-" "<-" "<=<" "=<<" "<<=" "<==" "<=>" "<==>"
                                             "==>" "=>" "=>>" ">=>" ">>=" ">>-" ">-" "-<" "-<<" ">->" "<-<" "<-|"
                                             "<=|" "|=>" "|->" "<->" "<~~" "<~" "<~>" "~~" "~~>" "~>" "~-" "-~"
                                             "~@" "[||]" "|]" "[|" "|}" "{|" "[<" ">]" "|>" "<|" "||>" "<||"
                                             "|||>" "<|||" "<|>" "..." ".." ".=" "..<" ".?" "::" ":::" ":=" "::="
                                             ":?" ":?>" "//" "///" "/*" "*/" "/=" "//=" "/==" "@_" "__" "???"
                                             "<:<" ";;;"))
        (global-ligature-mode t))
    #+end_src
** Initialize =editor-cnfig=
*** Description
    I want Emacs to apply the settings from =.editorconfig= files
*** Code
    #+begin_src emacs-lisp
      (use-package editorconfig
        :straight t
        :config
        (editorconfig-mode 1))
    #+end_src
** Initialize =consult=
*** Description
    Consult provides search and navigation commands based on the Emacs
    completion function =completing-read=. Completion allows you to quickly select an item
    from a list of candidates. Consult offers asynchronous and interactive =consult-grep= and
    =consult-ripgrep= commands, and the line-based search command =consult-line=.
    Furthermore Consult provides an advanced buffer switching command =consult-buffer= to switch
    between buffers, recently opened files, bookmarks and buffer-like candidates from
    other sources. Some of the Consult commands are enhanced versions of built-in Emacs commands.
*** Code
    #+begin_src emacs-lisp
      ;; Example configuration for Consult
      (use-package consult
        :straight t
        ;; Replace bindings. Lazily loaded due by `use-package'.
        :bind (;; C-c bindings in `mode-specific-map'
               ("C-c M-x" . consult-mode-command)
               ("C-c h" . consult-history)
               ("C-c k" . consult-kmacro)
               ("C-c m" . consult-man)
               ("C-c i" . consult-info)
               ([remap Info-search] . consult-info)
               ;; C-x bindings in `ctl-x-map'
               ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
               ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
               ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
               ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
               ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
               ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
               ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
               ;; Custom M-# bindings for fast register access
               ("M-#" . consult-register-load)
               ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
               ("C-M-#" . consult-register)
               ;; Other custom bindings
               ("M-y" . consult-yank-pop)                ;; orig. yank-pop
               ;; M-g bindings in `goto-map'
               ("M-g e" . consult-compile-error)
               ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
               ("M-g g" . consult-goto-line)             ;; orig. goto-line
               ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
               ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
               ("M-g m" . consult-mark)
               ("M-g k" . consult-global-mark)
               ("M-g i" . consult-imenu)
               ("M-g I" . consult-imenu-multi)
               ;; M-s bindings in `search-map'
               ("M-s d" . consult-find)                  ;; Alternative: consult-fd
               ("M-s c" . consult-locate)
               ("M-s g" . consult-grep)
               ("M-s G" . consult-git-grep)
               ("M-s r" . consult-ripgrep)
               ("M-s l" . consult-line)
               ("M-s L" . consult-line-multi)
               ("M-s k" . consult-keep-lines)
               ("M-s u" . consult-focus-lines)
               ;; Isearch integration
               ("M-s e" . consult-isearch-history)
               :map isearch-mode-map
               ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
               ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
               ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
               ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
               ;; Minibuffer history
               :map minibuffer-local-map
               ("M-s" . consult-history)                 ;; orig. next-matching-history-element
               ("M-r" . consult-history))                ;; orig. previous-matching-history-element

        ;; Enable automatic preview at point in the *Completions* buffer. This is
        ;; relevant when you use the default completion UI.
        :hook (completion-list-mode . consult-preview-at-point-mode)

        ;; The :init configuration is always executed (Not lazy)
        :init

        ;; Optionally configure the register formatting. This improves the register
        ;; preview for `consult-register', `consult-register-load',
        ;; `consult-register-store' and the Emacs built-ins.
        (setq register-preview-delay 0.5
              register-preview-function #'consult-register-format)

        ;; Optionally tweak the register preview window.
        ;; This adds thin lines, sorting and hides the mode line of the window.
        (advice-add #'register-preview :override #'consult-register-window)

        ;; Use Consult to select xref locations with preview
        (setq xref-show-xrefs-function #'consult-xref
              xref-show-definitions-function #'consult-xref)

        ;; Configure other variables and modes in the :config section,
        ;; after lazily loading the package.
        :config

        ;; Optionally configure preview. The default value
        ;; is 'any, such that any key triggers the preview.
        ;; (setq consult-preview-key 'any)
        ;; (setq consult-preview-key "M-.")
        ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
        ;; For some commands and buffer sources it is useful to configure the
        ;; :preview-key on a per-command basis using the `consult-customize' macro.
        (consult-customize
         consult--source-buffer :hidden t :default nil
         consult-theme :preview-key '(:debounce 0.2 any)
         consult-ripgrep consult-git-grep consult-grep
         consult-bookmark consult-recent-file consult-xref
         consult--source-bookmark consult--source-file-register
         consult--source-recent-file consult--source-project-recent-file
         ;; :preview-key "M-."
         :preview-key '(:debounce 0.4 any))
        (add-to-list 'consult-buffer-sources persp-consult-source)

        ;; Optionally configure the narrowing key.
        ;; Both < and C-+ work reasonably well.
        (setq consult-narrow-key "<") ;; "C-+"

        ;; Optionally make narrowing help available in the minibuffer.
        ;; You may want to use `embark-prefix-help-command' or which-key instead.
        ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

        ;; By default `consult-project-function' uses `project-root' from project.el.
        ;; Optionally configure a different project root function.
        ;;;; 1. project.el (the default)
        ;; (setq consult-project-function #'consult--default-project--function)
        ;;;; 2. vc.el (vc-root-dir)
        ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
        ;;;; 3. locate-dominating-file
        ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
        ;;;; 4. projectile.el (projectile-project-root)
        ;; (autoload 'projectile-project-root "projectile")
        ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
        ;;;; 5. No project support
        ;; (setq consult-project-function nil)
      )
    #+end_src
** Initialize =nix=
   #+begin_src emacs-lisp
     (use-package nix-mode
       :mode "\\.nix\\'")
   #+end_src
** Initialize =eat=
   #+begin_src emacs-lisp
     (use-package eat
       :straight (eat :type git
                     :host codeberg
                     :repo "akib/emacs-eat"
                     :files ("*.el" ("term" "term/*.el") "*.texi"
                             "*.ti" ("terminfo/e" "terminfo/e/*")
                             ("terminfo/65" "terminfo/65/*")
                             ("integration" "integration/*")
                             (:exclude ".dir-locals.el" "*-tests.el"))))
   #+end_src
** Built-in =savehist=
   #+begin_src emacs-lisp
     (use-package savehist
        :straight nil
        :config
        (savehist-mode))
   #+end_src
** Built-in entry: =abbrev=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package abbrev
        :straight nil
        :diminish abbrev-mode)
    #+END_SRC
** Built-in entry: =dired-x=
*** Code
    #+begin_src emacs-lisp
      (with-eval-after-load 'dired
        (require 'dired-x)
        ;; Set dired-x global variables here.  For example:
        (setq dired-guess-shell-gnutar "gtar")
        (setq dired-x-hands-off-my-keys nil))
      (add-hook 'dired-mode-hook
                (lambda ()
                  ;; Set dired-x buffer-local variables here.  For example:
                  (dired-omit-mode 1)))
    #+end_src
* Programming
** Initialize =direnv=
*** Code
    #+begin_src emacs-lisp
      (use-package direnv
        :straight t
        :custom ((direnv-always-show-summary nil)) ;; It's really annoying having the minibuffer popup each time I change envs
        :config
        (direnv-mode))
    #+end_src
** Initialize =tree-sitter=
*** Code
    #+BEGIN_SRC emacs-lisp
      (when (and (fboundp #'treesit-available-p)
                 (funcall #'treesit-available-p))
        (use-package treesit-auto
          :custom
          ((treesit-auto-install 'prompt)      
          (treesit-font-lock-level 4))
          :config
          (treesit-auto-add-to-auto-mode-alist 'all)
          (global-treesit-auto-mode)))
    #+END_SRC
** Initialize =YASnippets=
*** Description
    YASnippet is a template system for Emacs. It allows you to type an
    abbreviation and automatically expand it into function templates
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :straight t
        :demand t
        :diminish yas-minor-mode
        :custom ((yas-snippet-dirs `(,(concat user-emacs-directory "snippets")
                                     ,(concat straight-base-dir "straight/repos/yasnippet-snippets/snippets"))))
        :config
        (yas-global-mode 1))
      ;; Bundled snippets
      (use-package yasnippet-snippets
        :straight t)
    #+END_SRC
** Initialize =lua=
*** Code
    #+BEGIN_SRC emacs-lisp
  (use-package lua-mode
  :straight t
  :mode "\\.lua\\'"
  :interpreter "lua")
    #+END_SRC
** Initialize =corfu=
*** Description
    corfu is a text completion framework for Emacs.
    The name stands for "complete anything".
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package corfu
       :straight (corfu :files (:defaults "extensions/*")
                        :includes (corfu-info corfu-history))
       :demand t
       :custom
       (corfu-cycle t)    ; Allow cycling through candidates
       (corfu-auto t)     ; Enable auto completion
       (corfu-auto-prefix 2)
       (corfu-auto-delay 0.0)
       (corfu-quit-at-boundary 'separator)
       (corfu-echo-documentation 0.25)
       (corfu-preview-current nil) ;; Preview current candidate
       (corfu-preselect nil)
       (corfu-quit-no-match 'separator)
       ;; Optionally use TAB for cycling (default is `corfu-complete')
       :bind (:map corfu-map
                   ("M-SPC" . corfu-insert-separator)
                   ("TAB" . corfu-next)
                   ([tab] . corfu-next)
                   ("S-TAB" . corfu-previous)
                   ([backtab] . corfu-previous)
                   ("C-h" . corfu-info-documentation)
                   ("M-l" . corfu-info-location))
       :config
       (global-corfu-mode)
       (corfu-history-mode 1)
       :hook
       ((eshell-mode . (lambda ()
                         (setq-local corfu-quit-at-boundary t
                                     corfu-quit-no-match t
                                     corfu-auto nil)))))

    #+END_SRC
** Initialize =cape=
*** Code
    #+begin_src emacs-lisp
      (use-package cape
        :defer 1
        ;; Bind dedicated completion commands
        ;; Alternative prefix keys: C-c p, M-p, M-+, ...
        :bind (("C-c f p" . completion-at-point) ;; capf
               ("C-c f t" . complete-tag)        ;; etags
               ("C-c f d" . cape-dabbrev)        ;; or dabbrev-completion
               ("C-c f h" . cape-history)
               ("C-c f f" . cape-file)
               ("C-c f k" . cape-keyword)
               ("C-c f s" . cape-symbol)
               ("C-c f a" . cape-abbrev)
               ("C-c f i" . cape-ispell)
               ("C-c f l" . cape-line)
               ("C-c f w" . cape-dict)
               ("C-c f \\" . cape-tex)
               ("C-c f _" . cape-tex)
               ("C-c f ^" . cape-tex)
               ("C-c f &" . cape-sgml)
               ("C-c f r" . cape-rfc1345))
        :init
        ;; Add `completion-at-point-functions', used by `completion-at-point'.
        ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
        ;; cape-ispell is is failing to be defined in the .elc file
        ;; and breaks corfu
        ;; (add-to-list 'completion-at-point-functions #'cape-ispell)
        (add-to-list 'completion-at-point-functions #'cape-file)
        ;; (add-to-list 'completion-at-point-functions #'cape-history)
        ;; (add-to-list 'completion-at-point-functions #'cape-keyword)
        (add-to-list 'completion-at-point-functions #'cape-tex)
        (add-to-list 'completion-at-point-functions #'cape-sgml)
        (add-to-list 'completion-at-point-functions #'cape-rfc1345)
        ;; (add-to-list 'completion-at-point-functions #'cape-abbrev)
        ;; (add-to-list 'completion-at-point-functions #'cape-symbol)
        ;; (add-to-list 'completion-at-point-functions #'cape-line)
        )
    #+end_src
** Initialize =kind-icons=
*** Description
    This emacs package adds configurable icon or text-based completion prefixes
    based on the :company-kind property that many
    completion backends (such as lsp-mode and Emacs 28's elisp-mode) provide.
*** Code
    #+begin_src emacs-lisp
      (use-package kind-icon
        :straight t
        :after corfu
        :custom
        ((kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
         (kind-icons-use-icons t))
        :config
        (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
    #+end_src
** Initialize =eglot=
*** Code
    #+begin_src emacs-lisp
      (use-package eglot
        :straight nil
        :defer 1
        :custom
        (eglot-autoshutdown t)
        (eglot-extend-to-xref t)
        (eglot-ignored-server-capabilities '(:documentHighlightProvider))
        :hook
        ((typescript-mode . eglot-ensure)
         (tsx-ts-mode . eglot-ensure)
         (typescript-ts-mode . eglot-ensure)
         (c-ts-mode . eglot-ensure)
         (c-mode . eglot-ensure)
         (c++-mode . eglot-ensure)
         (c++-ts-mode . eglot-ensure)
         (js-mode . eglot-ensure)
         (js-ts-mode . eglot-ensure)
         (python-mode . eglot-ensure)
         (python-ts-mode . eglot-ensure)
         (java-mode . eglot-ensure)
         (java-ts-mode . eglot-ensure)
         (go-mode . eglot-ensure)
         (go-ts-mode . eglot-ensure))
        :config
        (add-to-list 'eglot-server-programs '(typescript-ts-mode . ("typescript-language-server" "--stdio")))
        (add-to-list 'eglot-server-programs '(tsx-ts-mode . ("typescript-language-server" "--stdio")))
        :bind (:map eglot-mode-map
                    ("C-c l r"   . eglot-rename)
                    ("C-c l f f" . eglot-format)
                    ("C-c l f b" . eglot-format-buffer)
                    ("C-c l a a" . eglot-code-actions)
                    ("C-c l a q" . eglot-code-action-quickfix)
                    ("C-c l a e" . eglot-code-action-extract)
                    ("C-c l a i" . eglot-code-action-inline)
                    ("C-c l a r" . eglot-code-action-rewrite)))
    #+end_src
** Initialize =dape=
*** Description
    Debug adapter
*** Code
    #+begin_src emacs-lisp
      (use-package dape
        :straight t
        :custom (
                 ;; By default dape shares the same keybinding prefix as `gud'
                 ;; If you do not want to use any prefix, set it to nil.
                 (dape-key-prefix (kbd "C-x C-a"))
                 ;; To use window configuration like gud (gdb-mi)
                 (dape-buffer-window-arrangement 'gud)
                 ;; Info buffers to the right
                 (dape-buffer-window-arrangement 'right)
                 ;; Projectile users
                 (dape-cwd-fn 'projectile-project-root))

        :hook
        ;; Save breakpoints on quit
        ((kill-emacs . dape-breakpoint-save)
         ;; Load breakpoints on startup
         (after-init . dape-breakpoint-load)
         ;; To display info and/or repl buffers on stopped
         (dape-on-stopped-hooks . dape-info)
         (dape-on-stopped-hooks . dape-repl)
         ;; Kill compile buffer on build success
         ;; (dape-compile-compile-hooks . kill-buffer)
         ;; Save buffers on startup, useful for interpreted languages
         ;; (dape-on-start-hooks . (lambda () (save-some-buffers t t)))
         )

        :config
        ;; Global bindings for setting breakpoints with mouse
        (dape-breakpoint-global-mode)

        ;; To not display info and/or buffers on startup
        (remove-hook 'dape-on-start-hooks 'dape-info)
        (remove-hook 'dape-on-start-hooks 'dape-repl))
    #+end_src
** Initialize =flymake=
*** Code
    #+begin_src emacs-lisp
      (use-package flymake
        :straight nil
        :custom
        (flymake-fringe-indicator-position nil)
        (flymake-fringe-indicator-position 'left-fringe)
        (help-at-pt-display-when-idle t) ;; Show diagnostic messages in echo area
        :bind
        (("M-n" . flymake-goto-next-error)
         ("M-p" . flymake-goto-prev-error)))

      (defun me/flymake-eslint-enable-maybe ()
        "Enable `flymake-eslint' based on the project configuration.
            Search for the project ESLint configuration to determine whether the buffer
            should be checked."
        (when-let* ((root (locate-dominating-file (buffer-file-name) "package.json"))
                    (rc (locate-file ".eslintrc" (list root) '(".js" ".json"))))
          (make-local-variable 'exec-path)
          (push (file-name-concat root "node_modules" ".bin") exec-path)
          (flymake-eslint-enable)))

      (use-package flymake-eslint
        :straight t)
    #+end_src
** Initialize =racket-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
    (use-package racket-mode
      :straight t
      :mode (("\\.rkt\\'" . racket-mode)
             ("\\.rhm\\'" . racket-hash-lang-mode)))
    #+END_SRC
** Initialize =go-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :straight t
        :custom ((go-ts-mode-indent-offset 4))
        :mode "\\.go\\'")
    #+END_SRC
** Initialize =php-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
    (use-package php-mode
      :straight t
      :mode "\\.php\\'")
    #+END_SRC
** Initialize =web-mode=
*** Description
    web-mode.el is an emacs major mode for editing web templates aka HTML
    files embedding parts (CSS/JavaScript) and blocks (pre rendered by
    client/server side engines).
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
          :straight t
          :mode ("\\.svelte?\\'"
                 "\\.html?\\'"
                 "\\.cshtml?\\'"
                 "\\.erb\\'"
                 "\\.phtml\\'"
                 "\\.blade\\.")
          :custom
          (web-mode-engines-alist '(("php"    . "\\.phtml\\'")
                                    ("blade"  . "\\.blade\\.")
                                    ("eruby"  . "\\.erb\\'"))))
    #+END_SRC
** Initialize =rust-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package rustic
        :straight t
        :mode (("\\.rs\\'" . rustic-mode))
        :custom
        (rustic-lsp-client 'eglot)
        (rustic-analyzer-command '("rustup" "run" "stable" "rust-analyzer")))
    #+END_SRC
    #+END_SRC
** Initialize =json-mode=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :straight t
        :mode "\\.json\\'")
    #+END_SRC
** Initialize =sly=
   #+BEGIN_SRC emacs-lisp
     (use-package sly
       :straight t
       :commands sly
       :config
       (setq inferior-lisp-program "sbcl"))
   #+END_SRC
** Initialize =Java=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package eglot-java
        :straight (eglot-java :type git :host github :repo "yveszoundi/eglot-java")
        :custom
        (eglot-java-server-install-dir "~/lsp/jdtls-lsp")
        :hook ((java-mode . eglot-java-mode))
        :bind (:map eglot-java-mode-map
                    ("C-c j n" . #'eglot-java-file-new)
                    ("C-c j x" . #'eglot-java-run-main)
                    ("C-c j t" . #'eglot-java-run-test)
                    ("C-c j p" . #'eglot-java-project-new)
                    ("C-c j T" . #'eglot-java-project-build-task)
                    ("C-c j R" . #'eglot-java-project-build-refresh)))
    #+END_SRC
** Initialize =yaml-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package yaml-mode
        :straight t
        :mode ("\\.yml\\'" "\\.yaml\\'"))
    #+end_src
** Initialize =restclient-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package restclient
        :straight t
        :commands restclient-mode)
    #+end_src
** Initialize =android-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package android-mode
        :straight t
        :commands android-mode)
    #+end_src
** Initialize =typescript-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package typescript-mode
        :straight (typescript-mode :type git :host github :redpo "emacs-typescript/typescript.el")
        :mode (("\\.ts\\>\\'" . typescript-ts-mode)))
    #+end_src
** Initialize =kotlin-mode=
   #+begin_src emacs-lisp
     (use-package kotlin-mode
       :straight t
       :mode ("\\.kt\\'" "\\.kts\\'" "\\.ktm\\'"))
   #+end_src
** Initialize =csharp-mode=
*** Code
    #+begin_src emacs-lisp
      (if (version<= emacs-version "29.0")
          (progn
            (use-package csharp-mode
              :straight t)
            (use-package omnisharp
              :straight t)
            (use-package csproj-mode
              :straight t)
            (use-package dotnet
              :straight t)))


      (add-hook 'csharp-mode-hook 'omnisharp-mode)
      (add-hook 'csharp-mode-hook 'dotnet-mode)
    #+end_src
** Initialize =clojure-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package clojure-mode
        :straight t
        :mode ("\\.clj\\'" "\\.cljs\\'" "\\.cljr\\'" "\\.cljc\\'" "\\.edn\\'"))
    #+end_src
** Initialize =CIDER=
*** Code
    #+begin_src emacs-lisp
      (use-package cider
        :straight t
        :hook ((closure-mode . cider)))
    #+end_src
** Initialize =gradle-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package gradle-mode
        :straight t
        :mode "\\.gradle\\'")
    #+end_src
** Initialize =groovy-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package groovy-mode
        :straight (groovy-mode :type git :host github :repo "Groovy-Emacs-Modes/groovy-emacs-modes")
        :mode ("\\.groovy\\'" "\\.gradle\\'"))
    #+end_src
** Initialize =pyvenv-mode=
*** Code
    #+begin_src emacs-lisp
      (use-package pyvenv
        :commands pyenv-mode)
    #+end_src
** Initialize =fasm-mode=
*** code
    #+begin_src emacs-lisp
      (use-package fasm-mode
        :straight t
        :mode "\\.fasm\\'")
    #+end_src
** Initiaze =git-gutter=
*** Code
    #+begin_src emacs-lisp
      (use-package git-gutter
        :straight t
        :demand t
        :custom ((git-gutter:modified-sign " ")
                 (git-gutter:added-sign " ")
                 (git-gutter:deleted-sign " "))
        :custom-face
        (git-gutter:modified ((t (:background "yellow"))))
        (git-gutter:added ((t (:background "green"))))
        (git-gutter:deleted ((t (:background "red"))))
        :bind (("C-x v ="   . git-gutter:popup-hunk)
               ("C-x v SPC" . git-gutter:mark-hunk)
               ("C-x v p"   . git-gutter:previous-hunk)
               ("C-x v n"   . git-gutter:next-hunk))
        :config
        (global-git-gutter-mode 1))
    #+end_src
** Built-in entry: =eldoc=
*** Code
    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :straight nil
        :after flymake
        :custom
        (eldoc-echo-area-use-multiline-p nil)
        :hook
        (typescript-ts-base-mode . eglot-ensure))
    #+END_SRC
